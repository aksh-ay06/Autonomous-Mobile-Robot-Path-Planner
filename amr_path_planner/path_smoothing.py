"""
Path smoothing and optimization algorithms for autonomous mobile robot navigation.
Provides various techniques to smooth and optimize paths generated by planning algorithms.
"""

import math
from typing import List, Tuple, Optional
import numpy as np
from .grid_map import GridMap


def euclidean_distance(pos1: Tuple[float, float], pos2: Tuple[float, float]) -> float:
    """Calculate Euclidean distance between two points."""
    return math.sqrt((pos1[0] - pos2[0])**2 + (pos1[1] - pos2[1])**2)


def line_collision_check(start: Tuple[float, float], end: Tuple[float, float], 
                        grid: GridMap, resolution: float = 0.1) -> bool:
    """
    Check if a line segment collides with obstacles using discrete sampling.
    
    Args:
        start: Start position
        end: End position
        grid: GridMap instance
        resolution: Sampling resolution for collision checking
        
    Returns:
        bool: True if collision detected, False otherwise
    """
    distance = euclidean_distance(start, end)
    if distance == 0:
        return not grid.is_free(int(start[0]), int(start[1]))
    
    steps = int(distance / resolution) + 1
    
    for i in range(steps + 1):
        t = i / steps if steps > 0 else 0
        x = start[0] + t * (end[0] - start[0])
        y = start[1] + t * (end[1] - start[1])
        
        # Check if this point is in collision
        grid_x, grid_y = int(round(x)), int(round(y))
        if not grid.is_free(grid_x, grid_y):
            return True
    
    return False


def shortcut_smoothing(path: List[Tuple[int, int]], grid: GridMap, 
                      max_iterations: int = 100) -> List[Tuple[int, int]]:
    """
    Apply shortcut smoothing to reduce path length by removing unnecessary waypoints.
    
    Args:
        path: Original path as list of (x, y) coordinates
        grid: GridMap instance for collision checking
        max_iterations: Maximum number of shortcut attempts
        
    Returns:
        Smoothed path with fewer waypoints
    """
    if len(path) <= 2:
        return path.copy()
    
    # Convert to float coordinates for smoother operations
    float_path = [(float(x), float(y)) for x, y in path]
    
    for _ in range(max_iterations):
        if len(float_path) <= 2:
            break
            
        # Randomly select two non-adjacent points
        i = np.random.randint(0, len(float_path) - 2)
        j = np.random.randint(i + 2, len(float_path))
        
        # Check if direct connection is collision-free
        if not line_collision_check(float_path[i], float_path[j], grid):
            # Remove intermediate points
            float_path = float_path[:i+1] + float_path[j:]
    
    # Convert back to integer coordinates
    return [(int(round(x)), int(round(y))) for x, y in float_path]


def bezier_smoothing(path: List[Tuple[int, int]], num_points: int = 50) -> List[Tuple[float, float]]:
    """
    Apply Bezier curve smoothing to create a smooth path.
    
    Args:
        path: Original path as list of (x, y) coordinates
        num_points: Number of points in the smoothed path
        
    Returns:
        Smoothed path as continuous coordinates
    """
    if len(path) <= 2:
        return [(float(x), float(y)) for x, y in path]
    
    # Convert to numpy array for easier manipulation
    path_array = np.array(path, dtype=float)
    
    # Generate control points for Bezier curve
    control_points = []
    
    for i in range(len(path_array)):
        if i == 0:
            # First point
            control_points.append(path_array[i])
        elif i == len(path_array) - 1:
            # Last point
            control_points.append(path_array[i])
        else:
            # Intermediate points - add smoothing
            prev_point = path_array[i-1]
            curr_point = path_array[i]
            next_point = path_array[i+1]
            
            # Calculate control points for smooth curve
            dir_in = curr_point - prev_point
            dir_out = next_point - curr_point
            
            # Normalize directions
            dir_in_norm = dir_in / (np.linalg.norm(dir_in) + 1e-6)
            dir_out_norm = dir_out / (np.linalg.norm(dir_out) + 1e-6)
            
            # Add control points before and after current point
            offset = 0.3  # Control the smoothness
            control_points.append(curr_point - dir_in_norm * offset)
            control_points.append(curr_point)
            control_points.append(curr_point + dir_out_norm * offset)
    
    # Generate smooth path using parametric interpolation
    smooth_path = []
    segments = len(path_array) - 1
    
    for i in range(segments):
        start_point = path_array[i]
        end_point = path_array[i + 1]
        
        # Simple linear interpolation for each segment
        for t in np.linspace(0, 1, num_points // segments + 1):
            if t < 1.0 or i == segments - 1:  # Avoid duplicate end points
                point = start_point + t * (end_point - start_point)
                smooth_path.append((float(point[0]), float(point[1])))
    
    return smooth_path


def spline_smoothing(path: List[Tuple[int, int]], smoothing_factor: float = 0.5) -> List[Tuple[float, float]]:
    """
    Apply spline smoothing using cubic interpolation.
    
    Args:
        path: Original path as list of (x, y) coordinates
        smoothing_factor: Factor controlling smoothness (0-1, higher = smoother)
        
    Returns:
        Smoothed path as continuous coordinates
    """
    if len(path) <= 2:
        return [(float(x), float(y)) for x, y in path]
    
    # Convert to numpy arrays
    path_array = np.array(path, dtype=float)
    x_coords = path_array[:, 0]
    y_coords = path_array[:, 1]
    
    # Parameter t for interpolation
    t = np.linspace(0, 1, len(path))
    
    # Create more points for smooth interpolation
    t_smooth = np.linspace(0, 1, len(path) * 5)
    
    # Cubic interpolation
    x_smooth = np.interp(t_smooth, t, x_coords)
    y_smooth = np.interp(t_smooth, t, y_coords)
    
    # Apply smoothing filter
    from scipy import ndimage
    try:
        sigma = smoothing_factor * 2  # Gaussian smoothing
        x_smooth = ndimage.gaussian_filter1d(x_smooth, sigma)
        y_smooth = ndimage.gaussian_filter1d(y_smooth, sigma)
    except ImportError:
        # Fallback: simple moving average if scipy not available
        window_size = max(1, int(smoothing_factor * 5))
        x_smooth = np.convolve(x_smooth, np.ones(window_size)/window_size, mode='same')
        y_smooth = np.convolve(y_smooth, np.ones(window_size)/window_size, mode='same')
    
    return [(float(x), float(y)) for x, y in zip(x_smooth, y_smooth)]


def adaptive_smoothing(path: List[Tuple[int, int]], grid: GridMap, 
                      curvature_threshold: float = 0.5) -> List[Tuple[int, int]]:
    """
    Apply adaptive smoothing that considers path curvature and obstacles.
    
    Args:
        path: Original path as list of (x, y) coordinates
        grid: GridMap instance for collision checking
        curvature_threshold: Threshold for determining sharp turns
        
    Returns:
        Adaptively smoothed path
    """
    if len(path) <= 2:
        return path.copy()
    
    smoothed_path = [path[0]]  # Start with first point
    
    i = 0
    while i < len(path) - 1:
        current_point = path[i]
        
        # Look ahead to find the farthest reachable point
        max_reach = i + 1
        for j in range(i + 2, min(i + 10, len(path))):  # Look up to 10 points ahead
            test_point = path[j]
            
            # Check if direct connection is possible
            if not line_collision_check(
                (float(current_point[0]), float(current_point[1])),
                (float(test_point[0]), float(test_point[1])),
                grid
            ):
                max_reach = j
            else:
                break
        
        # Calculate curvature at intermediate points
        if max_reach > i + 2:
            # Check if path has high curvature that should be preserved
            preserve_curve = False
            for k in range(i + 1, max_reach):
                if k < len(path) - 1:
                    curvature = calculate_curvature(path, k)
                    if curvature > curvature_threshold:
                        preserve_curve = True
                        max_reach = k
                        break
        
        # Add the reachable point
        if max_reach > i:
            smoothed_path.append(path[max_reach])
            i = max_reach
        else:
            i += 1
    
    # Ensure the last point is included
    if smoothed_path[-1] != path[-1]:
        smoothed_path.append(path[-1])
    
    return smoothed_path


def calculate_curvature(path: List[Tuple[int, int]], index: int) -> float:
    """
    Calculate the curvature at a given point in the path.
    
    Args:
        path: Path as list of (x, y) coordinates
        index: Index of point to calculate curvature for
        
    Returns:
        Curvature value (higher values indicate sharper turns)
    """
    if index <= 0 or index >= len(path) - 1:
        return 0.0
    
    p1 = np.array(path[index - 1], dtype=float)
    p2 = np.array(path[index], dtype=float)
    p3 = np.array(path[index + 1], dtype=float)
    
    # Calculate vectors
    v1 = p2 - p1
    v2 = p3 - p2
    
    # Calculate angle between vectors
    cos_angle = np.dot(v1, v2) / (np.linalg.norm(v1) * np.linalg.norm(v2) + 1e-6)
    cos_angle = np.clip(cos_angle, -1.0, 1.0)
    angle = np.arccos(cos_angle)
    
    # Return curvature (pi - angle, so 0 = straight, pi = sharp turn)
    return math.pi - angle


def douglas_peucker_smoothing(path: List[Tuple[int, int]], epsilon: float = 1.0) -> List[Tuple[int, int]]:
    """
    Apply Douglas-Peucker algorithm for path simplification.
    
    Args:
        path: Original path as list of (x, y) coordinates
        epsilon: Distance threshold for point removal
        
    Returns:
        Simplified path with fewer points
    """
    if len(path) <= 2:
        return path.copy()
    
    def point_line_distance(point: Tuple[int, int], line_start: Tuple[int, int], 
                           line_end: Tuple[int, int]) -> float:
        """Calculate perpendicular distance from point to line segment."""
        x0, y0 = point
        x1, y1 = line_start
        x2, y2 = line_end
        
        # Calculate distance using cross product
        numerator = abs((y2 - y1) * x0 - (x2 - x1) * y0 + x2 * y1 - y2 * x1)
        denominator = math.sqrt((y2 - y1)**2 + (x2 - x1)**2)
        
        return numerator / (denominator + 1e-6)
    
    def douglas_peucker_recursive(points: List[Tuple[int, int]], epsilon: float) -> List[Tuple[int, int]]:
        """Recursive Douglas-Peucker implementation."""
        if len(points) <= 2:
            return points
        
        # Find the point with maximum distance from line connecting first and last points
        max_distance = 0.0
        max_index = 0
        
        for i in range(1, len(points) - 1):
            distance = point_line_distance(points[i], points[0], points[-1])
            if distance > max_distance:
                max_distance = distance
                max_index = i
        
        # If max distance is greater than epsilon, recursively simplify
        if max_distance > epsilon:
            # Recursively simplify the two segments
            left_simplified = douglas_peucker_recursive(points[:max_index + 1], epsilon)
            right_simplified = douglas_peucker_recursive(points[max_index:], epsilon)
            
            # Combine results (remove duplicate middle point)
            return left_simplified[:-1] + right_simplified
        else:
            # All points are close to the line, return only endpoints
            return [points[0], points[-1]]
    
    return douglas_peucker_recursive(path, epsilon)


def smooth_path(path: List[Tuple[int, int]], grid: GridMap, 
               method: str = "shortcut", **kwargs) -> List[Tuple[int, int]]:
    """
    Apply path smoothing using specified method.
    
    Args:
        path: Original path as list of (x, y) coordinates
        grid: GridMap instance for collision checking
        method: Smoothing method ("shortcut", "adaptive", "douglas_peucker")
        **kwargs: Additional parameters for specific methods
        
    Returns:
        Smoothed path
    """
    if method == "shortcut":
        max_iterations = kwargs.get("max_iterations", 100)
        return shortcut_smoothing(path, grid, max_iterations)
    
    elif method == "adaptive":
        curvature_threshold = kwargs.get("curvature_threshold", 0.5)
        return adaptive_smoothing(path, grid, curvature_threshold)
    
    elif method == "douglas_peucker":
        epsilon = kwargs.get("epsilon", 1.0)
        return douglas_peucker_smoothing(path, epsilon)
    
    else:
        raise ValueError(f"Unknown smoothing method: {method}")


def path_length(path: List[Tuple[int, int]]) -> float:
    """Calculate total length of a path."""
    if len(path) <= 1:
        return 0.0
    
    total_length = 0.0
    for i in range(len(path) - 1):
        total_length += euclidean_distance(
            (float(path[i][0]), float(path[i][1])),
            (float(path[i+1][0]), float(path[i+1][1]))
        )
    
    return total_length


def path_curvature_analysis(path: List[Tuple[int, int]]) -> dict:
    """
    Analyze path curvature characteristics.
    
    Args:
        path: Path as list of (x, y) coordinates
        
    Returns:
        Dictionary with curvature statistics
    """
    if len(path) <= 2:
        return {
            "mean_curvature": 0.0,
            "max_curvature": 0.0,
            "sharp_turns": 0,
            "total_length": path_length(path)
        }
    
    curvatures = []
    for i in range(1, len(path) - 1):
        curvature = calculate_curvature(path, i)
        curvatures.append(curvature)
    
    sharp_turn_threshold = math.pi / 3  # 60 degrees
    sharp_turns = sum(1 for c in curvatures if c > sharp_turn_threshold)
    
    return {
        "mean_curvature": np.mean(curvatures) if curvatures else 0.0,
        "max_curvature": max(curvatures) if curvatures else 0.0,
        "sharp_turns": sharp_turns,
        "total_length": path_length(path),
        "num_waypoints": len(path)
    }


def analyze_path_smoothness(path: List[Tuple[int, int]]) -> dict:
    """
    Analyzes the smoothness of a given path.
    Calculates metrics like curvature, total angle change, etc.

    Args:
        path (List[Tuple[int, int]]): The path as a list of (x, y) coordinates.

    Returns:
        Dict[str, float]: A dictionary containing smoothness metrics.
                          Example: {'avg_curvature': 0.1, 'total_angle_change': 1.57}
    """
    if not path or len(path) < 3:
        return {
            "path_length": 0.0,
            "total_angle_change": 0.0,
            "avg_angle_change": 0.0,
            "max_angle_change": 0.0,
            "num_turns": 0,
            "avg_segment_length": 0.0
        }

    total_len = 0.0
    segment_lengths = []
    angles = []

    for i in range(len(path) - 1):
        p1 = np.array(path[i], dtype=float)
        p2 = np.array(path[i+1], dtype=float)
        
        dx = p2[0] - p1[0]
        dy = p2[1] - p1[1]
        segment_length = np.sqrt(dx**2 + dy**2)
        total_len += segment_length
        segment_lengths.append(segment_length)
        
        if i < len(path) - 2:
            p3 = np.array(path[i+2], dtype=float)
            vec1 = p2 - p1
            vec2 = p3 - p2
            
            dot_product = np.dot(vec1, vec2)
            mag_vec1 = np.linalg.norm(vec1)
            mag_vec2 = np.linalg.norm(vec2)
            
            if mag_vec1 > 1e-6 and mag_vec2 > 1e-6: # Avoid division by zero for zero-length segments
                cos_angle = dot_product / (mag_vec1 * mag_vec2)
                # Clamp cos_angle to [-1, 1] to avoid domain errors with acos due to precision issues
                cos_angle = np.clip(cos_angle, -1.0, 1.0)
                angle = np.arccos(cos_angle)
                angles.append(angle)
            else:
                angles.append(0.0) # No change in angle if a segment has zero length

    total_angle_change = np.sum(angles)
    avg_angle_change = np.mean(angles) if angles else 0.0
    max_angle_change = np.max(angles) if angles else 0.0
    # Consider a turn if angle is greater than a small threshold (e.g., 1 degree = ~0.017 radians)
    num_turns = sum(1 for angle in angles if angle > 0.017) 

    return {
        "path_length": float(total_len),
        "total_angle_change": float(total_angle_change),
        "avg_angle_change": float(avg_angle_change),
        "max_angle_change": float(max_angle_change),
        "num_turns": int(num_turns),
        "avg_segment_length": float(np.mean(segment_lengths) if segment_lengths else 0.0)
    }
